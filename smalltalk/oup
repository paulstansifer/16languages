<ul><li> The name for your variables changes depending on how much type information you give.  If something's used as a stack for parsing, but stored as an <tt>OrderedCollection</tt>, it makes sense to call it <tt>stack</tt>, sometimes.  Other times, programming in an explicitly-typed language, I've felt like it's stupid to give something a name other than it's type: "I want to reheapify the heap.  The only thing in scope that can be reheapified!"  Maybe I should just break down and use the name <tt>the</tt> in cases like that.  It seems classier than <tt>theHeap</tt>.  </li>
<li> I'm now learning XQuery at work.  I wonder how much interference there will be between XQuery and Smalltalk, given that they are basically each other's opposites.</li>
<li> I still haven't gotten used to duck typing, and not having to make type relationships explicit.  It's certainly nice to not have to share implementation to share interface &mdash; this seems to need to happen more than one would expect.</li>
<li> I have to admit that 1-based arrays aren't as strange as I had feared.  </li>
<li> This ad-hoc approach to writing a compiler seems to be working suprisingly well, 1/16th the way in.  It's suprisingly easy to say "Oh, I can push that functionality up/down a level."  It remains to be seen how I feel when I write the other sides of these kind of jagged interfaces.  </li>

