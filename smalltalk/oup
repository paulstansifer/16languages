This entry was accumulated over a long time.  Also, I'm playing with the syntax, so I've kinda overused italics.  
<ul><li> The "deeper" method names in Smalltalk make it easier to make more methods that do similar things differently: i.e. <tt>substring:len:</tt> vs. <tt>substring:until:</tt>.</li>
<li> Except that there isn't <i>any</i> substring in GNU Smalltalk!  The choice of methods is a little maddening, especially since I decided not to use regular expressions for the parsing.  (In fact, this is based on a grammar that I had previously which was parsed entirely by Perl regular expression replacements.</li>
<li> I'm utterly flummoxed by the lack of <tt>substring:</tt>.  I wound up using <tt>indexOfRegex:from:to:</tt> to do matching, and changing the syntax to not use any  regex metacharacters.  I think I'm missing something big here.</li>
<li> <tt>copyFrom:to:</tt> on on <tt>SequenceableCollection</tt>. Arggggh!  It took me sooooo long to figure that out.  <b>Argggh!</b></li>
<li> I realized that it was easier to use <tt>copyFrom:</tt> instead, which has even worse performance implications than what I originally tried.  When I saw that even my little test program incurred a garbage collection, I decided to implement a method that only matches against a substring.  (turns out that such a thing exists: <tt>matchSubCollection:startingAt:</tt> on <tt>SequenceableCollection</tt>)</li>
<li> Final score: I was frustrated for a long time by the nonexistence of something that existed and I turned out not to want to use!  If one flaw in my abilities as a programmer stands out above all the others, its my myopic obsession with attacking a problem in only one way.</li>
<li> I have one excuse: I was reluctant to tack on a new message to <tt>SequenceableCollection</tt> or <tt>String</tt>, out of resistance to namespace pollution.  It's not a good excuse, I know.</li>
<li> Anyways, I'm finally pretty happy with the parser.  In fact, this entry was written in its syntax and converted with it.  <strike>Except for one strange bug: For the items of syntax that consist of three characters in a row.</strike> Turns out that <tt>matchSubCollection:startingAt:</tt> wasn't doing quite what I wanted it to, so I had to rewrite it.  Still kinda myterious.  </li>
<li> <strike>Oh, I guess I could have used <tt>indexOf:startingAt:</tt> also.</strike>  Oops, no.  That's the index of an element, not a substring.  I hadn't noticed that such dual meanings could occur (<tt>indexOf:matchCase:startingAt:</tt> <i>does</i> operate on substrings, though, demonstrating that, sometimes, coming up with a good name for a method is just hard.</li>
<li> The syntax is as follows (I'm using preformatted text to suppress parsing, 'cause I haven't made any syntax for suppressing it yet.):</li>
<pre>* bulleted
* list
** nested
*** deeper
*# mixed
*# with
*# numbers
///Italic///, ***Bold***, [=teletype=], -s-strikethrough-s-
///Nesting ***is [=allowed=]***///
Link to Wikipedia article: [[Pet eye remover]]
 Start lines with a space 
 to make them preformatted,
^or a '^' to make a blockquote.
mdash:---  arrows:<-- --> <->
</pre></ul>Becomes:
<ul><li> bulleted</li>
<li> list</li>
<ul><li> nested</li>
<ul><li> deeper</li>
</ul></ul><ol><li> mixed</li>
<li> with</li>
<li> numbers</li>
</ol></ul><i>Italic</i>, <b>Bold</b>, <tt>teletype</tt>, <strike>strikethrough</strike>
<i>Nesting <b>is <tt>allowed</tt></b></i>
Link to Wikipedia article: <a href="http://en.wikipedia.org/wiki/Pet_eye_remover">Pet eye remover</a>
<pre>Start lines with a space 
to make them preformatted,
</pre><blockquote>or a '^' to make a blockquote.
</blockquote>mdash:&mdash;  arrows:&larr; &rarr; &harr;
<ul><li>I'm pretty happy with the code I've written for this.  It's a little long, but it's pretty nicely-structured; I should easily be able to add more elements, elements that nest with themselves, sanity checks, different kinds of syntax.  I intend to post the code later. </li>
Object: '' error: Invalid index 1: index out of range
SystemExceptions.IndexOutOfRange(Exception)>>signal
SystemExceptions.IndexOutOfRange class>>signalOn:withIndex:
String(Object)>>checkIndexableBounds:
String>>at:
PParser>>parseLine:
UndefinedObject>>executeStatements
